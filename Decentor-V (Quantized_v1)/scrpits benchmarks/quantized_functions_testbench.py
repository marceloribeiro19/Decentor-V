import numpy as np

# Q15 Frac Bits
Q15_FRAC_BITS = 8
Q7_FRAC_BITS = 7
# Lookup tables para SIGMOID e TANH (versão Q7)
sigmoidTable_q7 = np.array([
    0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e,
    0x50, 0x52, 0x53, 0x55, 0x57, 0x59, 0x5a, 0x5c,
    0x5e, 0x5f, 0x61, 0x62, 0x63, 0x65, 0x66, 0x67,
    0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70,
    0x71, 0x72, 0x72, 0x73, 0x74, 0x74, 0x75, 0x76,
    0x76, 0x77, 0x77, 0x78, 0x78, 0x79, 0x79, 0x7a,
    0x7a, 0x7a, 0x7b, 0x7b, 0x7b, 0x7c, 0x7c, 0x7c,
    0x7c, 0x7c, 0x7d, 0x7d, 0x7d, 0x7d, 0x7d, 0x7e,
    0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7f,
    0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
    0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
    0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
    0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
    0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
    0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
    0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04,
    0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x06,
    0x06, 0x06, 0x07, 0x07, 0x08, 0x08, 0x09, 0x09,
    0x0a, 0x0a, 0x0b, 0x0c, 0x0c, 0x0d, 0x0e, 0x0e,
    0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
    0x17, 0x19, 0x1a, 0x1b, 0x1d, 0x1e, 0x1f, 0x21,
    0x22, 0x24, 0x26, 0x27, 0x29, 0x2b, 0x2d, 0x2e,
    0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,
])

tanhTable_q7 = np.array([
    0x00, 0x08, 0x10, 0x18, 0x1f, 0x27, 0x2e, 0x35,
    0x3b, 0x41, 0x47, 0x4c, 0x51, 0x56, 0x5a, 0x5e,
    0x61, 0x65, 0x68, 0x6a, 0x6d, 0x6f, 0x71, 0x72,
    0x74, 0x75, 0x76, 0x78, 0x78, 0x79, 0x7a, 0x7b,
    0x7b, 0x7c, 0x7c, 0x7d, 0x7d, 0x7e, 0x7e, 0x7e,
    0x7e, 0x7e, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
    0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
    0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x81,
    0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x82,
    0x82, 0x82, 0x82, 0x82, 0x83, 0x83, 0x84, 0x84,
    0x85, 0x85, 0x86, 0x87, 0x88, 0x88, 0x8a, 0x8b,
    0x8c, 0x8e, 0x8f, 0x91, 0x93, 0x96, 0x98, 0x9b,
    0x9f, 0xa2, 0xa6, 0xaa, 0xaf, 0xb4, 0xb9, 0xbf,
    0xc5, 0xcb, 0xd2, 0xd9, 0xe1, 0xe8, 0xf0, 0xf8
], dtype=np.int8)
# Função de Ativação Q7
def pulp_nn_activations_direct_q7(data, int_width, act_func):
    shift_size = 3 - int_width
    lookup_table = sigmoidTable_q7 if act_func == "SIGMOID" else tanhTable_q7

    output = []
    for val in data:
        index = (val >> shift_size) & 0xFF  # Ajuste para índice válido
        index = max(0, min(index, len(lookup_table) - 1))  # Garante que está dentro dos limites
        
        # Converte corretamente para int8
        output.append(np.int8(lookup_table[index]))  
    return output

# Fast power of two
def fast_power_of_two(exp):
    return 1 << exp

def q_node_loss_pd_8bit(loss, output_trg, model_out):
    max_value = (1 << Q7_FRAC_BITS)  # Para quantização de 8 bits, usamos Q7_FRAC_BITS

    if loss == "MSE":
        return model_out - output_trg

    elif loss == "BCE":
        # Garantir que output não seja 0 ou max_value
        output = max(1, min(model_out, max_value - 1))

        # Cálculo do numerador
        num = ((output - output_trg) << Q7_FRAC_BITS)  # Shift para Q7

        # Cálculo do denominador
        den = (output * output) // fast_power_of_two(Q7_FRAC_BITS)  # (output² / 128)
        den = output - den  # output - (output² / 128)

        # **Correção baseada no C**: Ajustando o denominador para evitar divisão por zero
        if den == 0:
            den = 1  # Evita divisão por zero

        # Aplicando a divisão para obter o resultado final
        result = num // den  # Equivalente à divisão inteira em C

        return result

    elif loss == "CE":
        output = max(1, model_out)  # Evita divisão por zero
        return (output_trg << Q7_FRAC_BITS) // output

# Função da Derivada da Ativação Q15
def q_node_activation_pd(node_output, act_func):
    max_value = (1 << Q15_FRAC_BITS)

    if act_func == "RELU":
        return max_value if node_output > 0 else 0

    elif act_func == "SIGMOID":
        return (node_output * (max_value - node_output)) // fast_power_of_two(Q15_FRAC_BITS)

    elif act_func == "TANH":
        return max_value - (node_output * node_output) // fast_power_of_two(Q15_FRAC_BITS)

    return 0

# FIM DAS FUNÇOES - INICIO TESTBENCH #

def test_pulp_nn_activations():
    test_values = [-128, -64, 0, 64, 127]
    int_width = 1
    functions = ["SIGMOID", "TANH"]

    for func in functions:
        print(f"Testing {func} activation function:")
        output = pulp_nn_activations_direct_q7(test_values, int_width, func)
        for i, val in enumerate(test_values):
            print(f"  Input: {val} => Output: {output[i]}")
        print("\n")

def test_q_node_loss_pd():
    test_values = [(0, 13), (64, 64), (127, 115), (0, 115), (127, 13)]
    loss_functions = ["MSE", "BCE", "CE"]

    for loss in loss_functions:
        print(f"\nTesting {loss} loss function derivative:")
        for trg, out in test_values:
            result = q_node_loss_pd_8bit(loss, trg, out)
            print(f"  Target: {trg}, Output: {out} => Loss Derivative: {result}")
        print("\n")

def test_q_node_activation_pd():
    test_values = [0, 13, 26, 38, 51, 64, 77, 90, 102, 115, 127]
    functions = ["RELU", "SIGMOID", "TANH"]

    for func in functions:
        print(f"Testing {func} activation function derivative:")
        for val in test_values:
            result = q_node_activation_pd(val, func)
            print(f"  Input: {val} => Output: {result}")
        print("\n")

# Executando os testes
#test_pulp_nn_activations()
#print("\n")
test_q_node_loss_pd()
#print("\n")
#test_q_node_activation_pd()
